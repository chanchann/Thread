/*
TODO : 假如一个线程，先做为读者用 shared_lock 加锁，读完后忽然又想变成写者，该怎么办？

方法一：先解读者锁，再加写者锁。这种作法的问题是，一解一加之间，其余写者说不定已经介入并修改了数据，那么当前线程做为读者时所持有的状态（好比指针、迭代器）也就再也不有效。rem

方法二：用 upgrade_lock（仅限 Boost，STL 未提供），能够当作 shared_lock 用，可是必要时能够直接从读者「升级」为写者。


*/
